"""
Local Application Loop (Consumer)
Reviews and applies pakdiff files generated by the LLM loop.
"""
import os
import time
import subprocess
import glob
import shutil
from pathlib import Path
from datetime import datetime
from dotenv import load_dotenv
from pakagent_config import logger
def run_pak_command(args, cwd=None):
    """Execute pak command with given arguments"""
    try:
        cmd = ["pak"] + args
        logger.info(f"[Local Loop] Running: {' '.join(cmd)}")
        result = subprocess.run(
            cmd,
            cwd=cwd,
            capture_output=True,
            text=True,
            timeout=300
        )
        if result.returncode == 0:
            logger.info("[Local Loop] Pak command successful")
            if result.stdout:
                logger.info(f"[Local Loop] Output: {result.stdout}")
            return True
        else:
            logger.info(f"[Local Loop] Pak command failed (exit code {result.returncode})")
            if result.stderr:
                logger.info(f"[Local Loop] Error: {result.stderr}")
            if result.stdout:
                logger.info(f"[Local Loop] Output: {result.stdout}")
            return False
    except subprocess.TimeoutExpired:
        logger.info("[Local Loop] Pak command timed out")
        return False
    except FileNotFoundError:
        logger.info("[Local Loop] Error: 'pak' command not found. Make sure pak tool is installed.")
        return False
    except Exception as e:
        logger.info(f"[Local Loop] Error running pak command: {e}")
        return False
def apply_pakdiff(diff_file, target_dir):
    """Apply pakdiff file to target directory using pak v5.0.0"""
    logger.info(f"[Local Loop] **APPLYING PAKDIFF FORMAT** - Using pak v5.0.0 to surgically apply {diff_file}")
    args = ["-ad", diff_file, target_dir]
    return run_pak_command(args)
def preview_pakdiff_changes(diff_file):
    """Show a preview of what the pakdiff will change"""
    try:
        with open(diff_file, 'r') as f:
            content = f.read()
        logger.info("\n" + "="*60)
        logger.info("üìÑ PAKDIFF PREVIEW")
        logger.info("="*60)
        lines = content.split('\n')
        current_file = None
        in_replace_section = False
        for line in lines:
            if line.startswith('FILE:'):
                current_file = line.replace('FILE:', '').strip()
                logger.info(f"\nüîß File: {current_file}")
                in_replace_section = False
            elif line.startswith('FIND_METHOD:'):
                method = line.replace('FIND_METHOD:', '').strip()
                if method:
                    logger.info(f"  üéØ Finding method: {method}")
                else:
                    logger.info(f"  ‚ûï Adding new method")
            elif line.startswith('SECTION:'):
                section = line.replace('SECTION:', '').strip()
                logger.info(f"  üìù Section: {section}")
            elif line.startswith('UNTIL_EXCLUDE:'):
                until = line.replace('UNTIL_EXCLUDE:', '').strip()
                if until:
                    logger.info(f"  üõë Until: {until}")
            elif line.startswith('REPLACE_WITH:'):
                logger.info(f"  üîÑ Replacement:")
                in_replace_section = True
            elif in_replace_section and line.strip():
                logger.info(f"    {line}")
        logger.info("="*60)
    except Exception as e:
        logger.info(f"[Local Loop] Error previewing pakdiff: {e}")
def get_user_choice():
    """Get user choice for handling a pakdiff file"""
    while True:
        choice = input("\nü§î Choose action: (a)pply / (s)kip / (d)elete / (q)uit / (p)review again: ").lower().strip()
        if choice in ['a', 'apply']:
            return 'apply'
        elif choice in ['s', 'skip']:
            return 'skip'
        elif choice in ['d', 'delete']:
            return 'delete'
        elif choice in ['q', 'quit']:
            return 'quit'
        elif choice in ['p', 'preview']:
            return 'preview'
        else:
            logger.info("‚ùå Invalid choice. Please enter 'a', 's', 'd', 'q', or 'p'")
def move_to_archive(diff_file, archive_type, workflow_dir):
    """Move processed diff file to appropriate archive folder"""
    archive_dir = os.path.join(workflow_dir, archive_type)
    os.makedirs(archive_dir, exist_ok=True)
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    base_name = Path(diff_file).stem
    archived_name = f"{timestamp}_{base_name}.diff"
    archived_path = os.path.join(archive_dir, archived_name)
    shutil.move(diff_file, archived_path)
    logger.info(f"[Local Loop] Moved to archive: {archive_type}/{archived_name}")
    return archived_path
def local_application_loop():
    """Main local application loop - processes pakdiff files"""
    load_dotenv()
    WORKFLOW_DIR = os.environ["PAK_WORKFLOW_DIR"]
    SOURCE_DIR = os.environ["PAK_SOURCE_DIR"]
    logger.info(f"[Local Loop] Starting consumer loop")
    logger.info(f"[Local Loop] Workflow dir: {WORKFLOW_DIR}")
    logger.info(f"[Local Loop] Source dir: {SOURCE_DIR}")
    logger.info(f"[Local Loop] Watching for *.diff files...")
    processed_count = 0
    while True:
        try:
            diff_pattern = os.path.join(WORKFLOW_DIR, "*.diff")
            diff_files = sorted(glob.glob(diff_pattern))
            if not diff_files:
                logger.info(f"[Local Loop] No pakdiff files found. Checking again in 10s...")
                time.sleep(10)
                continue
            diff_file_to_process = diff_files[0]
            filename = os.path.basename(diff_file_to_process)
            processed_count += 1
            logger.info(f"\n[Local Loop] üéØ Found pakdiff file #{processed_count}: {filename}")
            preview_pakdiff_changes(diff_file_to_process)
            while True:
                choice = get_user_choice()
                if choice == 'preview':
                    preview_pakdiff_changes(diff_file_to_process)
                    continue
                elif choice == 'quit':
                    logger.info("[Local Loop] üõë User requested quit. Stopping...")
                    return
                else:
                    break
            if choice == 'apply':
                logger.info(f"[Local Loop] üöÄ Applying pakdiff to '{SOURCE_DIR}'...")
                if apply_pakdiff(diff_file_to_process, SOURCE_DIR):
                    logger.info("[Local Loop] ‚úÖ Pakdiff applied successfully!")
                    move_to_archive(diff_file_to_process, "applied", WORKFLOW_DIR)
                else:
                    logger.info("[Local Loop] ‚ùå Pakdiff application failed!")
                    move_to_archive(diff_file_to_process, "failed", WORKFLOW_DIR)
            elif choice == 'delete':
                logger.info("[Local Loop] üóëÔ∏è  Deleting pakdiff file...")
                os.remove(diff_file_to_process)
                logger.info(f"[Local Loop] Deleted: {filename}")
            elif choice == 'skip':
                logger.info("[Local Loop] ‚è≠Ô∏è  Skipping for now...")
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                skipped_name = f"skipped_{timestamp}_{filename}"
                skipped_path = os.path.join(WORKFLOW_DIR, skipped_name)
                shutil.move(diff_file_to_process, skipped_path)
                logger.info(f"[Local Loop] Renamed to: {skipped_name}")
            time.sleep(2)
        except KeyboardInterrupt:
            logger.info("\n[Local Loop] üõë Received interrupt signal. Stopping...")
            break
        except Exception as e:
            logger.info(f"[Local Loop] ‚ùå Unexpected error: {e}")
            time.sleep(5)
def main():
    """Main function for testing the local loop independently"""
    import tempfile
    if not os.environ.get("PAK_WORKFLOW_DIR"):
        test_dir = tempfile.mkdtemp(prefix="pak_local_test_")
        os.environ["PAK_WORKFLOW_DIR"] = test_dir
        logger.info(f"Test mode: Using {test_dir}")
    if not os.environ.get("PAK_SOURCE_DIR"):
        os.environ["PAK_SOURCE_DIR"] = os.getcwd()
    try:
        local_application_loop()
    except KeyboardInterrupt:
        logger.info("\nTest mode finished.")
if __name__ == "__main__":
    main()