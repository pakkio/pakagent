#!/usr/bin/env python3
"""
Local Application Loop (Consumer)
Reviews and applies pakdiff files generated by the LLM loop.
"""

import os
import time
import subprocess
import glob
import shutil
from pathlib import Path
from datetime import datetime
from dotenv import load_dotenv

# --- Helper Functions ---

def run_pak_command(args, cwd=None):
    """Execute pak command with given arguments"""
    try:
        cmd = ["pak"] + args
        print(f"[Local Loop] Running: {' '.join(cmd)}")
        
        result = subprocess.run(
            cmd,
            cwd=cwd,
            capture_output=True,
            text=True,
            timeout=300  # 5 minute timeout
        )
        
        if result.returncode == 0:
            print("[Local Loop] Pak command successful")
            if result.stdout:
                print(f"[Local Loop] Output: {result.stdout}")
            return True
        else:
            print(f"[Local Loop] Pak command failed (exit code {result.returncode})")
            if result.stderr:
                print(f"[Local Loop] Error: {result.stderr}")
            if result.stdout:
                print(f"[Local Loop] Output: {result.stdout}")
            return False
            
    except subprocess.TimeoutExpired:
        print("[Local Loop] Pak command timed out")
        return False
    except FileNotFoundError:
        print("[Local Loop] Error: 'pak' command not found. Make sure pak tool is installed.")
        return False
    except Exception as e:
        print(f"[Local Loop] Error running pak command: {e}")
        return False

def apply_pakdiff(diff_file, target_dir):
    """Apply pakdiff file to target directory using pak v5.0.0"""
    print(f"[Local Loop] **APPLYING PAKDIFF FORMAT** - Using pak v5.0.0 to surgically apply {diff_file}")
    args = ["-ad", diff_file, target_dir]
    return run_pak_command(args)

def preview_pakdiff_changes(diff_file):
    """Show a preview of what the pakdiff will change"""
    try:
        with open(diff_file, 'r') as f:
            content = f.read()
        
        print("\n" + "="*60)
        print("üìÑ PAKDIFF PREVIEW")
        print("="*60)
        
        lines = content.split('\n')
        current_file = None
        in_replace_section = False
        
        for line in lines:
            if line.startswith('FILE:'):
                current_file = line.replace('FILE:', '').strip()
                print(f"\nüîß File: {current_file}")
                in_replace_section = False
                
            elif line.startswith('FIND_METHOD:'):
                method = line.replace('FIND_METHOD:', '').strip()
                if method:
                    print(f"  üéØ Finding method: {method}")
                else:
                    print(f"  ‚ûï Adding new method")
                    
            elif line.startswith('SECTION:'):
                section = line.replace('SECTION:', '').strip()
                print(f"  üìù Section: {section}")
                
            elif line.startswith('UNTIL_EXCLUDE:'):
                until = line.replace('UNTIL_EXCLUDE:', '').strip()
                if until:
                    print(f"  üõë Until: {until}")
                    
            elif line.startswith('REPLACE_WITH:'):
                print(f"  üîÑ Replacement:")
                in_replace_section = True
                
            elif in_replace_section and line.strip():
                # Show first few lines of replacement
                print(f"    {line}")
                
        print("="*60)
        
    except Exception as e:
        print(f"[Local Loop] Error previewing pakdiff: {e}")

def get_user_choice():
    """Get user choice for handling a pakdiff file"""
    while True:
        choice = input("\nü§î Choose action: (a)pply / (s)kip / (d)elete / (q)uit / (p)review again: ").lower().strip()
        
        if choice in ['a', 'apply']:
            return 'apply'
        elif choice in ['s', 'skip']:
            return 'skip'
        elif choice in ['d', 'delete']:
            return 'delete'
        elif choice in ['q', 'quit']:
            return 'quit'
        elif choice in ['p', 'preview']:
            return 'preview'
        else:
            print("‚ùå Invalid choice. Please enter 'a', 's', 'd', 'q', or 'p'")

def move_to_archive(diff_file, archive_type, workflow_dir):
    """Move processed diff file to appropriate archive folder"""
    archive_dir = os.path.join(workflow_dir, archive_type)
    os.makedirs(archive_dir, exist_ok=True)
    
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    base_name = Path(diff_file).stem
    archived_name = f"{timestamp}_{base_name}.diff"
    archived_path = os.path.join(archive_dir, archived_name)
    
    shutil.move(diff_file, archived_path)
    print(f"[Local Loop] Moved to archive: {archive_type}/{archived_name}")
    return archived_path

# --- Main Loop ---

def local_application_loop():
    """Main local application loop - processes pakdiff files"""
    # Load environment variables
    load_dotenv()
    
    WORKFLOW_DIR = os.environ["PAK_WORKFLOW_DIR"]
    SOURCE_DIR = os.environ["PAK_SOURCE_DIR"]
    
    print(f"[Local Loop] Starting consumer loop")
    print(f"[Local Loop] Workflow dir: {WORKFLOW_DIR}")
    print(f"[Local Loop] Source dir: {SOURCE_DIR}")
    print(f"[Local Loop] Watching for *.diff files...")
    
    processed_count = 0
    
    while True:
        try:
            # 1. Scan for new .diff files
            diff_pattern = os.path.join(WORKFLOW_DIR, "*.diff")
            diff_files = sorted(glob.glob(diff_pattern))
            
            if not diff_files:
                print(f"[Local Loop] No pakdiff files found. Checking again in 10s...")
                time.sleep(10)
                continue
            
            # 2. Process the oldest diff file first
            diff_file_to_process = diff_files[0]
            filename = os.path.basename(diff_file_to_process)
            processed_count += 1
            
            print(f"\n[Local Loop] üéØ Found pakdiff file #{processed_count}: {filename}")
            
            # 3. Show preview and get user choice
            preview_pakdiff_changes(diff_file_to_process)
            
            while True:
                choice = get_user_choice()
                
                if choice == 'preview':
                    preview_pakdiff_changes(diff_file_to_process)
                    continue
                elif choice == 'quit':
                    print("[Local Loop] üõë User requested quit. Stopping...")
                    return
                else:
                    break
            
            # 4. Handle user choice
            if choice == 'apply':
                print(f"[Local Loop] üöÄ Applying pakdiff to '{SOURCE_DIR}'...")
                
                if apply_pakdiff(diff_file_to_process, SOURCE_DIR):
                    print("[Local Loop] ‚úÖ Pakdiff applied successfully!")
                    move_to_archive(diff_file_to_process, "applied", WORKFLOW_DIR)
                else:
                    print("[Local Loop] ‚ùå Pakdiff application failed!")
                    move_to_archive(diff_file_to_process, "failed", WORKFLOW_DIR)
                    
            elif choice == 'delete':
                print("[Local Loop] üóëÔ∏è  Deleting pakdiff file...")
                os.remove(diff_file_to_process)
                print(f"[Local Loop] Deleted: {filename}")
                
            elif choice == 'skip':
                print("[Local Loop] ‚è≠Ô∏è  Skipping for now...")
                # Move to back of queue by renaming with timestamp
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                skipped_name = f"skipped_{timestamp}_{filename}"
                skipped_path = os.path.join(WORKFLOW_DIR, skipped_name)
                shutil.move(diff_file_to_process, skipped_path)
                print(f"[Local Loop] Renamed to: {skipped_name}")
            
            # Small delay to prevent rapid cycling
            time.sleep(2)
            
        except KeyboardInterrupt:
            print("\n[Local Loop] üõë Received interrupt signal. Stopping...")
            break
        except Exception as e:
            print(f"[Local Loop] ‚ùå Unexpected error: {e}")
            time.sleep(5)  # Wait before continuing after error

def main():
    """Main function for testing the local loop independently"""
    # Set up test environment
    import tempfile
    
    if not os.environ.get("PAK_WORKFLOW_DIR"):
        test_dir = tempfile.mkdtemp(prefix="pak_local_test_")
        os.environ["PAK_WORKFLOW_DIR"] = test_dir
        print(f"Test mode: Using {test_dir}")
    
    if not os.environ.get("PAK_SOURCE_DIR"):
        os.environ["PAK_SOURCE_DIR"] = os.getcwd()
    
    try:
        local_application_loop()
    except KeyboardInterrupt:
        print("\nTest mode finished.")

if __name__ == "__main__":
    main()